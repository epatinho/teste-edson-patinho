{"version":3,"sources":["service-worker.ts"],"names":["CACHE_NAME","STATIC_ASSETS","self","__WB_MANIFEST","addEventListener","event","swEvent","skipWaiting","waitUntil","caches","open","then","cache","addAll","keys","cacheNames","Promise","all","filter","name","map","delete","clients","claim","msgEvent","data","type","fetchEvent","request","method","url","URL","hostname","location","some","asset","pathname","includes","respondWith","async","cachedResponse","match","networkResponse","fetch","status","put","clone","error","Response","headers","cacheFirstStrategy","requestClone","networkError","JSON","stringify","networkFirstStrategy"],"mappings":"mBAQA,MAAM,EAAa,uBAKb,GAFc,sKAAK,cAEH,CACpB,IACA,cACA,eACA,cACA,iBACA,eACA,eACA,iBAGF,KAAK,iBAAiB,UAAW,IAC/B,MAAM,EAAU,EAChB,KAAK,cACL,EAAQ,UACN,OAAO,KAAK,GAAY,KAAK,GACpB,EAAM,OAAO,IAAI,QAK9B,KAAK,iBAAiB,WAAY,IAChB,EACR,UACN,OAAO,OAAO,KAAK,GACV,QAAQ,IACb,EACG,OAAO,GAAQ,IAAS,GACxB,IAAI,GACI,OAAO,OAAO,OAK/B,KAAK,QAAQ,UAGf,KAAK,iBAAiB,UAAW,IAC/B,MAAM,EAAW,EACb,EAAS,MAA+B,iBAAvB,EAAS,KAAK,MACjC,KAAK,gBAqDT,KAAK,iBAAiB,QAAS,IAC7B,MAAM,EAAa,EACnB,GAAkC,QAA9B,EAAW,QAAQ,OAAkB,OACzC,MAAM,EAAM,IAAI,IAAI,EAAW,QAAQ,KAClB,oBAAjB,EAAI,SAKN,EAAI,WAAa,KAAK,SAAS,UAC/B,EAAc,KAAK,GAAS,EAAI,SAAS,SAAS,IAElD,EAAW,YA7DY,WACzB,IACE,MAAM,QAAuB,OAAO,MAAM,GAC1C,GAAI,EACF,OAAO,EAGT,MAAM,QAAwB,MAAM,GAOpC,OALI,GAA8C,MAA3B,EAAgB,eACjB,OAAO,KAAK,IAC1B,IAAI,EAAS,EAAgB,SAG9B,CACT,CAAE,MAAO,GACP,OAAO,IAAI,SAAS,UAAW,CAAE,OAAQ,IAAK,QAAS,CAAE,eAAgB,eAC3E,GA4CyB,CAAmB,EAAW,UAGvD,EAAW,YAAY,MAAM,EAAW,UAVtC,EAAW,YAlCc,WAC3B,IACE,MAAM,EAAe,EAAQ,QAE7B,IACE,MAAM,QAAwB,MAAM,GAOpC,OALI,GAA8C,MAA3B,EAAgB,eACjB,OAAO,KAAK,IAC1B,IAAI,EAAS,EAAgB,SAG9B,CACT,CAAE,MAAO,GACP,MAAM,QAAuB,OAAO,MAAM,GAC1C,GAAI,EACF,OAAO,EAGT,MAAM,CACR,CACF,CAAE,MAAO,GACP,OAAO,IAAI,SAAS,KAAK,UAAU,CAAE,MAAO,4BAAwB,CAClE,OAAQ,IACR,QAAS,CAAE,eAAgB,qBAE/B,GAQyB,CAAqB,EAAW","file":"service-worker.js","sourceRoot":"","sourcesContent":["declare global {\n  interface ServiceWorkerGlobalScope {\n    __WB_MANIFEST: Array<{ url: string; revision: string | null }>;\n  }\n}\n\ndeclare const self: ServiceWorkerGlobalScope;\n\nconst CACHE_NAME = 'spotify-app-cache-v1';\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconst urlsToCache = self.__WB_MANIFEST || [];\n\nconst STATIC_ASSETS = [\n  '/',\n  '/index.html',\n  '/static/css/',\n  '/static/js/',\n  '/manifest.json',\n  '/logo192.png',\n  '/logo512.png',\n  '/favicon.ico',\n];\n\nself.addEventListener('install', event => {\n  const swEvent = event as ExtendableEvent;\n  self.skipWaiting();\n  swEvent.waitUntil(\n    caches.open(CACHE_NAME).then(cache => {\n      return cache.addAll([...STATIC_ASSETS]);\n    })\n  );\n});\n\nself.addEventListener('activate', event => {\n  const swEvent = event as ExtendableEvent;\n  swEvent.waitUntil(\n    caches.keys().then(cacheNames => {\n      return Promise.all(\n        cacheNames\n          .filter(name => name !== CACHE_NAME)\n          .map(name => {\n            return caches.delete(name);\n          })\n      );\n    })\n  );\n  self.clients.claim();\n});\n\nself.addEventListener('message', event => {\n  const msgEvent = event as ExtendableMessageEvent;\n  if (msgEvent.data && msgEvent.data.type === 'SKIP_WAITING') {\n    self.skipWaiting();\n  }\n});\n\nconst cacheFirstStrategy = async (request: Request) => {\n  try {\n    const cachedResponse = await caches.match(request);\n    if (cachedResponse) {\n      return cachedResponse;\n    }\n\n    const networkResponse = await fetch(request);\n\n    if (networkResponse && networkResponse.status === 200) {\n      const cache = await caches.open(CACHE_NAME);\n      cache.put(request, networkResponse.clone());\n    }\n\n    return networkResponse;\n  } catch (error) {\n    return new Response('Offline', { status: 503, headers: { 'Content-Type': 'text/plain' } });\n  }\n};\n\nconst networkFirstStrategy = async (request: Request) => {\n  try {\n    const requestClone = request.clone();\n\n    try {\n      const networkResponse = await fetch(requestClone);\n\n      if (networkResponse && networkResponse.status === 200) {\n        const cache = await caches.open(CACHE_NAME);\n        cache.put(request, networkResponse.clone());\n      }\n\n      return networkResponse;\n    } catch (networkError) {\n      const cachedResponse = await caches.match(request);\n      if (cachedResponse) {\n        return cachedResponse;\n      }\n\n      throw networkError;\n    }\n  } catch (error) {\n    return new Response(JSON.stringify({ error: 'Você está offline' }), {\n      status: 503,\n      headers: { 'Content-Type': 'application/json' },\n    });\n  }\n};\n\nself.addEventListener('fetch', event => {\n  const fetchEvent = event as FetchEvent;\n  if (fetchEvent.request.method !== 'GET') return;\n  const url = new URL(fetchEvent.request.url);\n  if (url.hostname === 'api.spotify.com') {\n    fetchEvent.respondWith(networkFirstStrategy(fetchEvent.request));\n    return;\n  }\n  if (\n    url.hostname === self.location.hostname ||\n    STATIC_ASSETS.some(asset => url.pathname.includes(asset))\n  ) {\n    fetchEvent.respondWith(cacheFirstStrategy(fetchEvent.request));\n    return;\n  }\n  fetchEvent.respondWith(fetch(fetchEvent.request));\n});\nexport {};\n"]}